<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: attribute_proxy.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: attribute_proxy.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
//# Attribute Obj Proxy handler
const createAttrProxy = function(attrs){
  //creates a proxy for the attributes object so that values can be worked with more easily.
  const getCascObj = function(event,casc){
    let typePrefix = event.htmlAttributes ? 'act_' : 'attr_';
    let cascName = `${typePrefix}${event.sourceAttribute}`;
    let cascObj = casc[cascName];
    return cascObj;
  };
  
  const triggerFunctions = function(obj,attributes,sections){
    if(obj.triggeredFuncs &amp;&amp; obj.triggeredFuncs.length){
      debug(`triggering functions for ${obj.name}`);
      obj.triggeredFuncs &amp;&amp; obj.triggeredFuncs.forEach(func=>funcs[func] ? 
        funcs[func]({trigger:obj,attributes,sections}) :
        debug(`!!!Warning!!! no function named ${func} found. Triggered function not called for ${obj.name}`,true));
    }
  };
  
  const initialFunction = function(obj,attributes,sections){
    if(obj.initialFunc){
      debug(`initial functions for ${obj.name}`);
      funcs[obj.initialFunc] ?
        funcs[obj.initialFunc]({trigger:obj,attributes,sections}) :
        debug(`!!!Warning!!! no function named ${obj.initialFunc} found. Initial function not called for ${obj.name}`,true);
    }
  };
  const processChange = function({event,trigger,attributes,sections,casc}){
    debug({trigger});
    if(event &amp;&amp; !trigger){
      debug('initial change detected. No trigger found');
      return;
    }
    if(!attributes || !sections || !casc){
      debug(`!!! Insufficient arguments || attributes > ${!!attributes} | sections > ${!!sections} | casc > ${!!casc} !!!`);
      return;
    }
    //store the queue in attributes.
    if(event){
      debug('checking for initial functions');
      initialFunction(trigger,attributes,sections);//functions that should only be run if the attribute was the thing changed by the user
    }
    if(trigger){
      debug(`processing ${trigger.name}`);
      triggerFunctions(trigger,attributes,sections);
      if(!event &amp;&amp; trigger.calculation){
        attributes[trigger.name] = funcs[trigger.calculation]({trigger,attributes,sections});
      }
      if(Array.isArray(trigger.affects)){
        attributes.queue.push(...trigger.affects);
      }
    }
    attributes.set({attributes,sections,casc});
  };
  const attrTarget = {
    updates:{},
    attributes:{...attrs},
    repOrders:{},
    queue: [],
    casc:{},
    processChange,
    triggerFunctions,
    initialFunction,
    getCascObj
  };
  const attrHandler = {
    get:function(obj,prop){//gets the most value of the attribute.
      //If it is a repeating order, returns the array, otherwise returns the update value or the original value
      if(prop === 'set'){
        return function(){
          let {attributes,sections,casc,callback,vocal} = arguments[0] ? arguments[0] : {};
          if(attributes &amp;&amp; attributes.queue.length &amp;&amp; sections &amp;&amp; casc){
            let triggerName = attributes.queue.shift();
            let trigger = getCascObj({sourceAttribute:triggerName},casc);
            attributes.processChange({trigger,attributes,sections,casc});
          }else{
            debug({updates:obj.updates});
            let trueCallback = Object.keys(obj.repOrders).length ?
              function(){
                Object.entries(obj.repOrders).forEach(([section,order])=>{
                  _setSectionOrder(section,order,)
                });
                callback &amp;&amp; callback();
              }:
              callback;
            Object.keys(obj.updates).forEach((key)=>obj.attributes[key] = obj.updates[key]);
            const update = obj.updates;
            obj.updates = {};
            set(update,vocal,trueCallback);
          }
        }
      }else if(Object.keys(obj).some(key=>key===prop)){ 
        return Reflect.get(...arguments)
      }else{
        let retValue;
        switch(true){
          case obj.repOrders.hasOwnProperty(prop):
            retValue = obj.repOrders[prop];
            break;
          case obj.updates.hasOwnProperty(prop):
            retValue = obj.updates[prop];
            break;
          default:
            retValue = obj.attributes[prop];
            break;
        }
        let cascRef = `attr_${prop.replace(/(repeating_[^_]+_)[^_]+/,'$1\$x')}`;
        let numRetVal = +retValue;
        if(!Number.isNaN(numRetVal) &amp;&amp; retValue !== ''){
          retValue = numRetVal;
        }else if(cascades[cascRef] &amp;&amp; typeof cascades[cascRef].defaultValue === 'number'){
          retValue = cascades[cascRef].defaultValue;
        }
        return retValue;
      }
    },
    set:function(obj,prop,value){
      //Sets the value. Also verifies that the value is a valid attribute value
      //e.g. not undefined, null, or NaN
      if(value || value===0 || value===''){
        if(/reporder|^repeating_[^_]+$/.test(prop)){
          let section = prop.replace(/_reporder_/,'');
          obj.repOrders[section] = value;
        }else if(`${obj.attributes}` !== `${value}` || 
          (obj.updates[prop] &amp;&amp; `${obj.updates}` !== `${value}`)
        ){
          obj.updates[prop] = value;
        }
      }else{
        debug(`!!!Warning: Attempted to set ${prop} to an invalid value:${value}; value not stored!!!`);
      }
      return true;
    },
    deleteProperty(obj,prop){
      //removes the property from the original attributes, updates, and the reporders
      Object.keys(obj).forEach((key)=>{
        delete obj[key][prop.toLowerCase()];
      });
    }
  };
  return new Proxy(attrTarget,attrHandler);
};

const funcs = {};

/**
 * Function that registers a function for being called via the funcs object. Returns true if the function was successfully registered, and false if it could not be registered for any reason.
 * @param {object} funcObj - Object with keys that are names to register functions under and values that are functions.
 * @returns {boolean}
 */
const registerFuncs = function(funcObj){
  Object.entries(funcObj).forEach(([prop,value])=>{
    if(funcs[prop]){
      debug(`!!! Duplicate function name for ${prop} !!!`);
      return false;
    }else if(typeof value === 'function'){
      funcs[prop] = value;
      return true;
    }else{
      debug(`!!! k.funcs should only store function calls. Invalid value to store in k.funcs !!!`);
      return false;
    }
  });
  debug({'after registration':funcs});
};
kFuncs.registerFuncs = registerFuncs;

/**
 * Function to call a function previously registered to the funcs object. May not be used that much. Either returns the function or null if no function exists.
 * @param {any} funcName - The name of the function to invoke.
 * @param {...any} args - The arguments to call the function with.
 * @returns {any}
 */
const callFunc = function(funcName,...args){
  if(funcs[funcName]){
    debug(`calling ${funcName}`);
    return funcs[funcName](...args);
  }else{
    debug(`Invalid function name: ${funcName}`);
    return null;
  }
};
kFuncs.callFunc = callFunc;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#accessSheet">accessSheet</a></li><li><a href="global.html#callFunc">callFunc</a></li><li><a href="global.html#capitalize">capitalize</a></li><li><a href="global.html#commaArray">commaArray</a></li><li><a href="global.html#debug">debug</a></li><li><a href="global.html#debugMode">debugMode</a></li><li><a href="global.html#extractQueryResult">extractQueryResult</a></li><li><a href="global.html#generateRowID">generateRowID</a></li><li><a href="global.html#getAllAttrs">getAllAttrs</a></li><li><a href="global.html#getAttrs">getAttrs</a></li><li><a href="global.html#getSections">getSections</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#orderSection">orderSection</a></li><li><a href="global.html#orderSections">orderSections</a></li><li><a href="global.html#parseHTMLName">parseHTMLName</a></li><li><a href="global.html#parseRepeatName">parseRepeatName</a></li><li><a href="global.html#parseTriggerName">parseTriggerName</a></li><li><a href="global.html#pseudoQuery">pseudoQuery</a></li><li><a href="global.html#registerFuncs">registerFuncs</a></li><li><a href="global.html#removeRepeatingRow">removeRepeatingRow</a></li><li><a href="global.html#sanitizeForRegex">sanitizeForRegex</a></li><li><a href="global.html#setAttrs">setAttrs</a></li><li><a href="global.html#setSectionOrder">setSectionOrder</a></li><li><a href="global.html#sheetName">sheetName</a></li><li><a href="global.html#updateHandlers">updateHandlers</a></li><li><a href="global.html#value">value</a></li><li><a href="global.html#version">version</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Tue Jan 25 2022 10:33:29 GMT-0700 (Mountain Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
