
<textarea name="attr_kjsdocs" title="@{kjsdocs}"></textarea>
<textarea name="attr_kpugdocs" title="@{kpugdocs}"></textarea>
<script type="text/worker">
  const k = (function(){
  const kFuncs = {};
  
  const cascades = {"attr_kjsdocs":{"name":"kjsdocs","defaultValue":"","triggeredFuncs":[],"affects":[]},"attr_kpugdocs":{"name":"kpugdocs","defaultValue":"","triggeredFuncs":[],"affects":[]}};
  
  kFuncs.cascades = cascades;
  
  const repeatingSectionDetails = [];
  
  kFuncs.repeatingSectionDetails = repeatingSectionDetails;
  
  const docs = {"js":{},"pug":{}};
  
  kFuncs.docs = docs;
  /*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
/**
 * This stores the name of your sheet for use in the logging functions {@link log} and {@link debug}
 * * @var
 * @type {string}
 */
docs.js.sheetName = {
	type:'string',
	description:'This stores the name of your sheet for use in the logging functions [k.log](#klog) and [k.debug](#kdebug).'
};
let sheetName = 'kScaffold Powered Sheet';
kFuncs.sheetName = sheetName;
/**
	* This stores the version of your sheet for use in the logging functions{@link log} and {@link debug}. It is also stored in the sheet_version attribute on your character sheet.
	* @var
	* @type {number}
	*/
docs.js.version = {
	type:'number',
	description:'This stores the version of your sheet for use in the logging functions [k.log](#klog) and [k.debug](#kdebug), and in the K-scaffolds sheet versioning handling. It is also stored in the sheet_version attribute on your character sheet.'
};
let version = 0;
kFuncs.version = version;
/**
	* A boolean flag that tells the script whether to enable or disable {@link debug} calls. If the version of the sheet is `0`, or an attribute named `debug_mode` is found on opening this is set to true for your entire session. Otherwise, it remains false.
	* @var
	* @type {boolean}
	*/
docs.js.debugMode = {
	type:'boolean',
	description:'A boolean flag that tells the script whether to enable or disable [k.debug](#kdebug) calls. If the version of the sheet is `0`, or an attribute named `debug_mode` is found on opening this is set to true for all sheets you open from that point on. Otherwise, it remains false.'
};
let debugMode = false;
kFuncs.debugMode = debugMode;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
docs.js['k.sanitizeForRegex'] = {
  type:'function',
  invocation:`k.sanitizeForRegex(text)`,
  description:'Replaces problem characters to use a string as a regex.',
  arguments:[
    {type:'string',name:'text',description:'The text to replace characters in.'}
  ]
};
const sanitizeForRegex = function(text){
  return text.replace(/\.|\||\(|\)|\[|\]|\-|\+|\?|\/|\{|\}|\^|\$|\*/g,'\\$&');
};
kFuncs.sanitizeForRegex = sanitizeForRegex;

docs.js['k.value'] = {
  type:'function',
  invocation:`k.value(val,def)`,
  description:'Converts a value to a number, it\'s default value, or `0` if no default value passed.',
  arguments:[
    {type:'any',name:'val',description:'The value to coerce into a number.'},
    {type:'number',name:'def',description:'A default value to use, if not passed, 0 is used instead.'}
  ]
};
const value = function(val,def){
  return (+val||def||0);
};
kFuncs.value = value;

docs.js['k.parseRepeatName'] = {
  type:'function',
  invocation:`k.parseRepeatName(string)`,
  description:'Extracts the section (e.g. `repeating_equipment`), rowID (e.g `-;lkj098J:LKj`), and field name (e.g. `bulk`) from a repeating attribute name.',
  arguments:[
    {type:'string',name:'string',description:'The attribute name to parse.'}
  ],
  retValue:{
    type:'array',
    description:'For a repeating attribute named `repeating_equipment_-LKJhpoi98;lj_weight`, the array will be `[\'repeating_equipment\',\'-LKJhpoi98;lj\',\'weight\']`.'
  }
};
const parseRepeatName = function(string){
  let match = string.match(/(repeating_[^_]+)_([^_]+)(?:_(.+))?/);
  match.shift();
  return match;
};
kFuncs.parseRepeatName = parseRepeatName;

docs.js['k.parseTriggerName'] = {
  type:'function',
  invocation:`k.parseTriggerName(string)`,
  description:'Parses out the components of a trigger name similar to {@link parseRepeatName}. Aliases: parseClickTrigger.\n\nAliases: `k.parseClickTrigger`',
  arguments:[
    {type:'string',name:'string',description:'The triggerName property of the [event](https://wiki.roll20.net/Sheet_Worker_Scripts#eventInfo_Object).'}
  ],
  retValue:{
    type:'array',
    description:'For a repeating button named `repeating_equipment_-LKJhpoi98;lj_roll`, the array will be `[\'repeating_equipment\',\'-LKJhpoi98;lj\',\'roll\']`. For a non repeating button named `roll`, the array will be `[undefined,undefined,\'roll\']`'
  }
};
const parseTriggerName = function(string){
  let match = string.replace(/^clicked:/,'').match(/(?:(repeating_[^_]+)_([^_]+)_)?(.+)/);
  match.shift();
  return match;
};
kFuncs.parseTriggerName = parseTriggerName;
const parseClickTrigger = parseTriggerName;
kFuncs.parseClickTrigger = parseClickTrigger;

docs.js['k.parseHTMLName'] = {
  type:'function',
  invocation:`k.parseHTMLName(string)`,
  description:'Parses out the attribute name from the htmlattribute name.',
  arguments:[
    {type:'string',name:'string',description:'The triggerName property of the [event](https://wiki.roll20.net/Sheet_Worker_Scripts#eventInfo_Object).'}
  ],
  retValue:{
    type:'array',
    description:'For a repeating button named `act_repeating_equipment_-LKJhpoi98;lj_roll`, the array will be `[\'repeating_equipment\',\'-LKJhpoi98;lj\',\'roll\']`. For a non repeating button named `act_roll`, the array will be `[undefined,undefined,\'roll\']`'
  }
};
const parseHTMLName = function(string){
  let match = string.match(/(?:attr|act|roll)_(.+)/);
  match.shift();
  return match[0];
};
kFuncs.parseHTMLName = parseHTMLName;

docs.js['k.capitalize'] = {
  type:'function',
  invocation:`k.capitalize(string)`,
  description:'Capitalize each word in a string.',
  arguments:[
    {type:'string',name:'string',description:'The string to capitalize'},
  ],
  retValue:{
    type:'string',
    description:'The capitalized string'
  }
};
const capitalize = function(string){
  return string.replace(/(?:^|\s+|\/)[a-z]/ig,(letter)=>letter.toUpperCase());
};
kFuncs.capitalize = capitalize;

docs.js['k.extractQueryResult'] = {
  type:'function',
  invocation:`k.extractQueryResult(section,sections,customText)`,
  description:'Extracts a roll query result for use in later functions. Must be awaited as per [startRoll documentation](https://wiki.roll20.net/Sheet_Worker_Scripts#Roll_Parsing.28NEW.29). Stolen from [Oosh\'s Adventures with Startroll thread](https://app.roll20.net/forum/post/10346883/adventures-with-startroll).',
  arguments:[
    {type:'string',name:'query',description:'The query should be just the text as the `?{` and `}` at the start/end of the query are added by the function.'}
  ],
  retValue:{
    type:'string',
    description:'The selected value from the roll query'
  }
};
const extractQueryResult = async function(query){
	debug('entering extractQueryResult');
	let queryRoll = await startRoll(`!{{query=[[0[response=?{${query}}]]]}}`);
	finishRoll(queryRoll.rollId);
	return queryRoll.results.query.expression.replace(/^.+?response=|\]$/g,'');
};
kFuncs.extractQueryResult = extractQueryResult;

docs.js['k.pseudoQuery'] = {
  type:'function',
  invocation:`k.pseudoQuery(section,sections,customText)`,
  description:'Simulates a query for ensuring that async/await works correctly in the sheetworker environment when doing conditional startRolls. E.g. if you have an if/else and only one of the conditions results in `startRoll` being called (and thus an `await`), the sheetworker environment would normally crash. Awaiting this in the condition that does not actually need to call `startRoll` will keep the environment in sync.',
  arguments:[
    {type:'number|string',name:'value',description:'The value to return. Optional.'}
  ],
  retValue:{
    type:'string',
    description:'The `value` passed to the function is returned after startRoll resolves.'
  }
};
const pseudoQuery = async function(value){
	debug('entering pseudoQuery');
	let queryRoll = await startRoll(`!{{query=[[0[response=${value}]]]}}`);
	finishRoll(queryRoll.rollId);
	return queryRoll.results.query.expression.replace(/^.+?response=|\]$/g,'');
};
kFuncs.pseudoQuery = pseudoQuery;

docs.js['k.log'] = {
  type:'function',
  invocation:`k.log(msg)`,
  description:'An alias for console.log.',
  arguments:[
    {type:'string|object|array',name:'msg',description:'The message can be a straight string, an object, or an array. If it is an object or array, the object will be broken down so that each key is used as a label to output followed by the value of that key. If the value of the key is an object or array, it will be output via `console.table`.'}
  ]
};
const log = function(msg){
  if(typeof msg === 'string'){
    console.log(`%c${kFuncs.sheetName} log| ${msg}`,"background-color:#159ccf");
  }else if(typeof msg === 'object'){
    Object.keys(msg).forEach((m)=>{
      if(typeof msg[m] === 'string'){
        console.log(`%c${kFuncs.sheetName} log| ${m}: ${msg[m]}`,"background-color:#159ccf");
      }else{
        console.log(`%c${kFuncs.sheetName} log| ${typeof msg[m]} ${m}`,"background-color:#159ccf");
        console.table(msg[m]);
      }
    });
  }
};
kFuncs.log = log;

docs.js['k.debug'] = {
  type:'function',
  invocation:`k.debug(msg,force)`,
  description:'Alias for console.log that only triggers when debug mode is enabled or when the sheet\'s version is `0`.',
  arguments:[
    {type:'string',name:'setObj',description:'See [k.log](#klog)'},
    {type:'boolean',name:'force',description:'Pass as a truthy value to force the debug output to be output to the console regardless of debug mode.'}
  ]
};
const debug = function(msg,force){
  if(!kFuncs.debugMode && !force && kFuncs.version > 0) return;
  if(typeof msg === 'string'){
    console.log(`%c${kFuncs.sheetName} DEBUG| ${msg}`,"background-color:tan;color:red;");
  }else if(typeof msg === 'object'){
    Object.keys(msg).forEach((m)=>{
      if(typeof msg[m] === 'string'){
        console.log(`%c${kFuncs.sheetName} DEBUG| ${m}: ${msg[m]}`,"background-color:tan;color:red;");
      }else{
        console.log(`%c${kFuncs.sheetName} DEBUG| ${typeof msg[m]} ${m}`,"background-color:tan;color:red;font-weight:bold;");
        console.table(msg[m]);
      }
    });
  }
};
kFuncs.debug = debug;

docs.js['k.orderSections'] = {
  type:'function',
  invocation:`k.orderSections(attributes,sections)`,
  description:'Orders the section id arrays for all sections in the `sections` object to match the repOrder attribute.',
  arguments:[
    {type:'object',name:'attributes',description:'The attributes object that must have a value for the reporder for each section.'},
    {type:'object',name:'sections',description:'Object containing the IDs for the repeating sections, indexed by repeating section name.'}
  ]
};
const orderSections = function(attributes,sections){
  Object.keys(sections).forEach((section)=>{
    attributes.attributes[`_reporder_${section}`] = commaArray(attributes[`_reporder_${section}`]);
    orderSection(attributes.attributes[`_reporder_${section}`],sections[section]);
  });
};
kFuncs.orderSections = orderSections;

docs.js['k.orderSection'] = {
  type:'function',
  invocation:`k.orderSection(repOrder,IDs)`,
  description:'Orders a single ID array.',
  arguments:[
    {type:'array',name:'setObj',description:'Array of IDs in the order they are in on the sheet.'},
    {type:'array',name:'vocal',description:'Array of IDs to be ordered.'}
  ]
};
const orderSection = function(repOrder,IDs=[]){
  IDs.sort((a,b)=>{
    return repOrder.indexOf(a.toLowerCase()) - repOrder.indexOf(b.toLowerCase());
  });
};
kFuncs.orderSection = orderSection;

/**
 * Splits a comma delimited string into an array
 * @param {string} [string='']
 * @returns {string[]}
 */
docs.js['k.commaArray'] = {
  type:'function',
  invocation:`k.commaArray(string)`,
  description:'Splits a comma delimited string into an array',
  arguments:[
    {type:'string',name:'setObj',description:'The string to split.'}
  ],
  retValue:{
    type:'array',
    description:'The string segments of the comma delimited list.'
  }
};
const commaArray = function(string=''){
  return string.toLowerCase().split(/\s*,\s*/);
};
kFuncs.commaArray = commaArray;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
//# Attribute Obj Proxy handler
docs.js['K-Scaffold Attribute Object'] = {
  type:'object',
description:`The attributes object that is passed as the first agrument to the callbacks from [k.getAttrs()](#kgetattrs) and [k.getAllAttrs](#kgetallattrs). This is a proxy for the basic attributes object passed to the callback in the sheetworker [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29) and has been upgraded with several new abilities.`,
  arguments:[
    {type:'string|number',name:'name of attribute',description:'The attribute value you are accessing. Accessing the attribute value will return the most recent value and the value will be converted into a number if it should be.'},

    {type:'function',name:'set({vocal,callback,attributes,sections,casc})',description:'Applies any updates that are currently cached to the sheet. This function uses [the destructuring assignment pattern](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).'},
    {type:'boolean',name:'set.vocal',description:'Set will not be silent. Inverts the standard behavior of setAttrs options object.'},
    {type:'function',name:'set.callback',description:'A callback to be invoked once the setAttrs is completed'},
    {type:'object',name:'set.attributes',description:'The instance of the K-scaffold Attribute Object to use for further set operations'},
    {type:'object',name:'set.sections',description:'An object containing the idArrays for each repeating section, indexed by full section name (e.g. `repeating_equipment`)'},
    {type:'object',name:'set.casc',description:'As the casc property described below.'},

    {type:'object',name:'attributes',description:'An object that contains the original attribute values as returned by [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29). Original attribute values can always be accessed by callin them from this property directly, e.g. `attributes.attributes.strength`'},
    {type:'object',name:'updates',description:'An object that contains all the attribute values that need to be set on the sheet.'},
    {type:'object',name:'repOrders',description:'An object containing the idArrays for each repeating section that need to be udpated, indexed by full section name (e.g. `repeating_equipment`)'},
    {type:'array',name:'queue',description:'The queue of attributes to work through.'},
    {type:'object',name:'casc',description:'The expanded version of the [cascades object](#cascades).'},

    {type:'function',name:'processChange({event,trigger,attributes,sections,casc})',description:'Function to iterate through attribute changes for default handling. Uses [the destructuring assignment pattern](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).'},
    {type:'object',name:'processChange.event',description:'[A Roll20 event object](https://wiki.roll20.net/Sheet_Worker_Scripts#eventInfo_Object).'},
    {type:'object',name:'processChange.trigger',description:'The trigger object as contained in [cascades](#cascades)'},
    {type:'object',name:'processChange.attributes',description:'The K-scaffold Attribute object to use'},
    {type:'object',name:'processChange.sections',description:'An object containing the idArrays for each repeating section, indexed by full section name (e.g. `repeating_equipment`)'},
    {type:'object',name:'processChange.casc',description:'As the casc object above.'},

    {type:'function',name:'triggerFunctions(trigger,attributes,sections)',description:'Calls functions that are triggered whenever an attribute is changed or affected'},
    {type:'object',name:'triggerFunctions.trigger',description:'The trigger object as contained in the [cascades object](#cascades)'},
    {type:'object',name:'triggerFunctions.attributes',description:'The attributes object.'},
    {type:'object',name:'triggerFunctions.sections',description:'An object containing the idArrays for each repeating section, indexed by full section name (e.g. `repeating_equipment`)'},

    {type:'function',name:'initialFunction(trigger,attributes,sections)',description:'Calls functions that are only triggered when an attribute is the triggering event'},
    {type:'object',name:'initialFunction.trigger',description:'The trigger object as contained in the [cascades object](#cascades)'},
    {type:'object',name:'initialFunction.attributes',description:'The attributes object.'},
    {type:'object',name:'initialFunction.sections',description:'An object containing the idArrays for each repeating section, indexed by full section name (e.g. `repeating_equipment`)'},

    {type:'function',name:'getCascObj(event,casc)',description:'Gets the appropriate cascade object for a given attribute or action button'},
    {type:'object',name:'event',descrition:'[A Roll20 event object](https://wiki.roll20.net/Sheet_Worker_Scripts#eventInfo_Object).'},
    {type:'object',name:'getCascObj.casc',description:'As the casc object above.'},
  ]
};
const createAttrProxy = function(attrs){
  //creates a proxy for the attributes object so that values can be worked with more easily.
  const getCascObj = function(event,casc){
    let typePrefix = event.htmlAttributes ? 'act_' : 'attr_';
    let cascName = `${typePrefix}${event.sourceAttribute}`;
    let cascObj = casc[cascName];
    return cascObj;
  };
  
  const triggerFunctions = function(trigger,attributes,sections){
    if(trigger.triggeredFuncs && trigger.triggeredFuncs.length){
      debug(`triggering functions for ${trigger.name}`);
      trigger.triggeredFuncs && trigger.triggeredFuncs.forEach(func=>funcs[func] ? 
        funcs[func]({trigger,attributes,sections}) :
        debug(`!!!Warning!!! no function named ${func} found. Triggered function not called for ${trigger.name}`,true));
    }
  };
  
  const initialFunction = function(trigger,attributes,sections){
    if(trigger.initialFunc){
      debug(`initial functions for ${obj.name}`);
      funcs[trigger.initialFunc] ?
        funcs[trigger.initialFunc]({trigger:trigger,attributes,sections}) :
        debug(`!!!Warning!!! no function named ${trigger.initialFunc} found. Initial function not called for ${trigger.name}`,true);
    }
  };
  const processChange = function({event,trigger,attributes,sections,casc}){
    debug({trigger});
    if(event && !trigger){
      debug('initial change detected. No trigger found');
      return;
    }
    if(!attributes || !sections || !casc){
      debug(`!!! Insufficient arguments || attributes > ${!!attributes} | sections > ${!!sections} | casc > ${!!casc} !!!`);
      return;
    }
    //store the queue in attributes.
    if(event){
      debug('checking for initial functions');
      initialFunction(trigger,attributes,sections);//functions that should only be run if the attribute was the thing changed by the user
    }
    if(trigger){
      debug(`processing ${trigger.name}`);
      triggerFunctions(trigger,attributes,sections);
      if(!event && trigger.calculation){
        attributes[trigger.name] = funcs[trigger.calculation]({trigger,attributes,sections,casc});
      }
      if(Array.isArray(trigger.affects)){
        attributes.queue.push(...trigger.affects);
      }
    }
    attributes.set({attributes,sections,casc});
  };
  const attrTarget = {
    updates:{},
    attributes:{...attrs},
    repOrders:{},
    queue: [],
    casc:{},
    processChange,
    triggerFunctions,
    initialFunction,
    getCascObj
  };
  const attrHandler = {
    get:function(obj,prop){//gets the most value of the attribute.
      //If it is a repeating order, returns the array, otherwise returns the update value or the original value
      if(prop === 'set'){
        return function(){
          let {attributes,sections,casc,callback,vocal} = arguments[0] ? arguments[0] : {};
          if(attributes && attributes.queue.length && sections && casc){
            let triggerName = attributes.queue.shift();
            let trigger = getCascObj({sourceAttribute:triggerName},casc);
            attributes.processChange({trigger,attributes,sections,casc});
          }else{
            debug({updates:obj.updates});
            let trueCallback = Object.keys(obj.repOrders).length ?
              function(){
                Object.entries(obj.repOrders).forEach(([section,order])=>{
                  _setSectionOrder(section,order,)
                });
                callback && callback();
              }:
              callback;
            Object.keys(obj.updates).forEach((key)=>obj.attributes[key] = obj.updates[key]);
            const update = obj.updates;
            obj.updates = {};
            set(update,vocal,trueCallback);
          }
        }
      }else if(Object.keys(obj).some(key=>key===prop)){ 
        return Reflect.get(...arguments)
      }else{
        let retValue;
        switch(true){
          case obj.repOrders.hasOwnProperty(prop):
            retValue = obj.repOrders[prop];
            break;
          case obj.updates.hasOwnProperty(prop):
            retValue = obj.updates[prop];
            break;
          default:
            retValue = obj.attributes[prop];
            break;
        }
        let cascRef = `attr_${prop.replace(/(repeating_[^_]+_)[^_]+/,'$1\$x')}`;
        let numRetVal = +retValue;
        if(!Number.isNaN(numRetVal) && retValue !== ''){
          retValue = numRetVal;
        }else if(cascades[cascRef] && typeof cascades[cascRef].defaultValue === 'number'){
          retValue = cascades[cascRef].defaultValue;
        }
        return retValue;
      }
    },
    set:function(obj,prop,value){
      //Sets the value. Also verifies that the value is a valid attribute value
      //e.g. not undefined, null, or NaN
      if(value || value===0 || value===''){
        if(/reporder|^repeating_[^_]+$/.test(prop)){
          let section = prop.replace(/_reporder_/,'');
          obj.repOrders[section] = value;
        }else if(`${obj.attributes}` !== `${value}` || 
          (obj.updates[prop] && `${obj.updates}` !== `${value}`)
        ){
          obj.updates[prop] = value;
        }
      }else{
        debug(`!!!Warning: Attempted to set ${prop} to an invalid value:${value}; value not stored!!!`);
      }
      return true;
    },
    deleteProperty(obj,prop){
      //removes the property from the original attributes, updates, and the reporders
      Object.keys(obj).forEach((key)=>{
        delete obj[key][prop.toLowerCase()];
      });
    }
  };
  return new Proxy(attrTarget,attrHandler);
};

const funcs = {};

docs.js['k.registerFuncs'] = {
  type:'function',
  description:'Function that registers a function for being called via the funcs object. Returns true if the function was successfully registered, and false if it could not be registered for any reason.',
  arguments:[
    {type:'object',name:'funcObj',description:'Object with keys that are names to register functions under and values that are functions.'},
    {type:'object',name:'optionsObj',description:'Object that contains options to use for this registration.'},
    {type:'[\'strings\']',name:'optionsObj.type',description:'Array that contains the types of specialized functions that apply to the functions being registered. Valid types are `"opener"`, `"updater"`, and `"default"`. `"default"` is always used, and never needs to be passed.'}
  ],
  retValue:{
    type:'boolean',
    description:'True if the registration succeeded, false if it failed.'
  }
};
const registerFuncs = function(funcObj,optionsObj = {}){
  if(typeof funcObj !== 'object' || typeof optionsObj !== 'object'){
    debug(`!!!! K-scaffold error: Improper arguments to register functions !!!!`);
    return false;
  }
  const typeArr = optionsObj.type ? ['default',...optionsObj.type] : ['default'];
  const typeSwitch = {
    'opener':openHandlers,
    'updater':updateHandlers,
    'default':funcs
  };
  let setState;
  Object.entries(funcObj).map(([prop,value])=>{
    typeArr.forEach((type)=>{
      if(typeSwitch[type][prop]){
        debug(`!!! Duplicate function name for ${prop} as ${type}!!!`);
        setState = false;
      }else if(typeof value === 'function'){
        typeSwitch[type][prop] = value;
        setState = setState !== false ? true : false;
      }else{
        debug(`!!! K-scaffold error: Function registration requires a function. Invalid value to register as ${type} !!!`);
        setState = false;
      }
    });
  });
  return setState;
};
kFuncs.registerFuncs = registerFuncs;

docs.js['k.callFunc'] = {
  type:'function',
  description:'Function to call a function previously registered to the funcs object. May not be used that much. Either returns the function or null if no function exists.',
  arguments:[
    {type:'string',name:'funcName',description:'The name of the function to invoke.'},
    {type:'any',name:'args',description:'The arguments to call the function with.'}
  ],
  retValue:{
    type:'any',
  }
};
const callFunc = function(funcName,...args){
  if(funcs[funcName]){
    debug(`calling ${funcName}`);
    return funcs[funcName](...args);
  }else{
    debug(`Invalid function name: ${funcName}`);
    return null;
  }
};
kFuncs.callFunc = callFunc;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
//Sheet Updaters and styling functions
const updateHandlers = {};
const openHandlers = {};
const updateSheet = function(){
  log('updating sheet');
  getAllAttrs({props:['sheet_version','debug_mode','collapsed',...baseGet],
    callback:(attributes,sections,casc)=>{
      kFuncs.debugMode = !!attributes.debug_mode;
      if(!attributes.sheet_version){
        initialSetup(attributes,sections);
      }else{
        Object.entries(updateHandlers).forEach(([ver,handler])=>{
          if(attributes.version < +ver){
            handler({attributes,sections,casc});
          }
        });
      }
      Object.entries(openHandlers).forEach(([funcName,func])=>{
        debug(`running ${funcName}`);
        func({attributes,sections,casc});
      });
      attributes.sheet_version = kFuncs.version;
      log(`Sheet Update applied. Current Sheet Version ${kFuncs.version}`);
      //styleOnOpen(attributes,sections);
      //setActionCalls({attributes,sections});
      debug({casc});
      ['pug','js'].forEach((type)=>{
        if(casc[`attr_k${type}docs`]){
          attributes[`k${type}docs`] = docGen(type);
          debug({[`k${type}docs`]:attributes[`k${type}docs`]});
        }
      });
      attributes.set();
      log('Sheet ready for use');
    }
  });
};

const docGen = function(type){
  debug(`doc gen for ${type}`);
  debug({docs});
  let pugHead = [`# K Scaffold ${type.toUpperCase()} documentation`];
  return Object.entries(docs[type]).reduce((text,[name,docObj])=>{
    let type = docObj.type;
    text.push(`## \`${type}\` - ${docObj.name || name}`);
    if(docObj.description){
      text.push(docObj.description);
    }
    let args = Array.isArray(docObj.arguments) ? docObj.arguments : [];
    args.forEach((a)=>{
      text.push(`- \`${a.type}\` - ${a.name}: ${a.description || ''}`)
    });
    let example = Array.isArray(docObj.example) ? docObj.example : [];
    if(example.length){
      text.push(`### Example${example.length > 1 ? 's' : ''}`);
    }
    example.forEach((eArr)=>{
      text.push(
        `**${type.toUpperCase()}**`,
        `\`\`\`js`,
        eArr[0],
        `\`\`\``
      );
      if(type === 'pug'){
        text.push(
          '**HTML**',
          `\`\`\`html`,
          eArr[0],
          `\`\`\``
        );
      }
    });
    if(docObj.retValue){
      text.push(`- \`${docObj.retValue.type}\` - ${docObj.retValue.description}`)
    }
    return text;
  },pugHead).join('\n');
};

const initialSetup = function(attributes,sections){
debug('Initial sheet setup');
};

docs.js.accessSheet = {
  name:'k.accessSheet',
  type:'function',
  description:'The default listener for the K-scaffold. Used whenever a `listenerFunc` is not specified in an attribute\'s trigger object',
  arguments:[
    {type:'object',name:'event',description:'The event from the Roll20 trigger as described in [the wiki](https://wiki.roll20.net/Sheet_Worker_Scripts#eventInfo_Object)'}
  ]
};
const accessSheet = function(event){
debug({funcs:Object.keys(funcs)});
debug({event});
getAllAttrs({event,callback:(attributes,sections,casc)=>{
  let trigger = attributes.getCascObj(event,casc);
  attributes.processChange({event,trigger,attributes,sections,casc});
}});
};
funcs.accessSheet = accessSheet;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
/*
Cascade Expansion functions
*/
//Expands the repeating section templates in cascades to reflect the rows actually available
const expandCascade = function(cascade,sections,attributes){
  return _.keys(cascade).reduce((memo,key)=>{//iterate through cascades and replace references to repeating attributes with correct row ids.
    if(/^(?:act|attr)_repeating_/.test(key)){//If the attribute is a repeating attribute, do special logic
      expandRepeating(memo,key,cascade,sections,attributes);
    }else if(key){//for non repeating attributes do this logic
      expandNormal(memo,key,cascade,sections);
    }
    return memo;
  },{});
};

const expandRepeating = function(memo,key,cascade,sections,attributes){
  key.replace(/((?:attr|act)_)(repeating_[^_]+)_[^_]+?_(.+)/,(match,type,section,field)=>{
    (sections[section]||[]).forEach((id)=>{
      memo[`${type}${section}_${id}_${field}`]=_.clone(cascade[key]);//clone the details so that each row's attributes have correct ids
      memo[`${type}${section}_${id}_${field}`].name = `${section}_${id}_${field}`;
      if(key.startsWith('attr_')){
        memo[`${type}${section}_${id}_${field}`].affects = memo[`${type}${section}_${id}_${field}`].affects.reduce((m,affected)=>{
          if(section === affected){//otherwise if the affected attribute is in the same section, simply set the affected attribute to have the same row id.
            m.push(applyID(affected,id));
          }else if(/repeating/.test(affected)){//If the affected attribute isn't in the same repeating section but is still a repeating attribute, add all the rows of that section
            addAllRows(affected,m,sections);
          }else{//otherwise the affected attribute is a non repeating attribute. Simply add it to the computed affected array
            m.push(affected);
          }
          return m;
        },[]);
      }
    });
  });
};

const applyID = function(affected,id){
  return affected.replace(/(repeating_[^_]+_)[^_]+(.+)/,`$1${id}$2`);
};

const expandNormal = function(memo,key,cascade,sections){
  memo[key] = _.clone(cascade[key]);
  if(key.startsWith('attr_')){
    memo[key].affects = memo[key].affects.reduce((m,a)=>{
      if(/^repeating/.test(a)){
        addAllRows(a,m,sections);
      }else{
        m.push(a);
      }
      return m;
    },[]);
  }
};

const addAllRows = function(affected,memo,sections){
  affected.replace(/(repeating_[^_]+?)_[^_]+?_(.+)/,(match,section,field)=>{
    sections[section].forEach(id=>memo.push(`${section}_${id}_${field}`));
  });
};/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
/**
 * Alias for [setSectionOrder()](https://wiki.roll20.net/Sheet_Worker_Scripts#setSectionOrder.28.3CRepeating_Section_Name.3E.2C_.3CSection_Array.3E.2C_.3CCallback.3E.29) that allows you to use the section name in either `repeating_section` or `section` formats.
 * @name setSectionOrder
 * @param {string} section
 * @param {string[]} order
 * @returns {void}
 */
docs.js['k.setSectionOrder'] = {
  type:'function',
  description:'Alias for [setSectionOrder()](https://wiki.roll20.net/Sheet_Worker_Scripts#setSectionOrder.28.3CRepeating_Section_Name.3E.2C_.3CSection_Array.3E.2C_.3CCallback.3E.29) that allows you to use the section name in either `repeating_section` or `section` formats. Note that the Roll20 sheetworker [setSectionOrder](https://wiki.roll20.net/Sheet_Worker_Scripts#setSectionOrder.28.3CRepeating_Section_Name.3E.2C_.3CSection_Array.3E.2C_.3CCallback.3E.29) currently causes some display issues on sheets.',
  arguments:[
    {type:'string',name:'section',description:'The name of the section to change the order in. Accepts the section name with or without the `repeating_` prefix.'},
    {type:'[\'string\']',name:'order',description:'Array of the row ids in the order that the rows need to be placed.'}
  ]
};
const _setSectionOrder = function(section,order){
  let trueSection = section.replace(/repeating_/,'');
  setSectionOrder(trueSection,order);
};
kFuncs.setSectionOrder = _setSectionOrder;

/**
 * Alias for [removeRepeatingRow](https://wiki.roll20.net/Sheet_Worker_Scripts#removeRepeatingRow.28_RowID_.29) that also removes the row from the current object of attribute values and array of section IDs to ensure that erroneous updates are not issued.
 * @name removeRepeatingRow
 * @param {string} row - The row id to be removed
 * @param {attributesProxy} attributes - The attribute values currently in memory
 * @param {object} sections - Object that contains arrays of all the IDs in sections on the sheet indexed by repeating name.
 * @returns {void}
 */
docs.js['k.removeRepeatingRow'] = {
  type:'function',
  description:'Alias for [removeRepeatingRow](https://wiki.roll20.net/Sheet_Worker_Scripts#removeRepeatingRow.28_RowID_.29) that also removes the row from the current object of attribute values and array of section IDs to ensure that erroneous updates are not issued.',
  arguments:[
    {type:'string',name:'row',description:'The row id including the section name, e.g. `repeating_equipment_-oiuLKJ987ulkj`.'},
    {type:'object',name:'attributes',description:'The attributes object passed to the callback in [k.getAllAttrs()](#getAllAttrs), [k.getAttrs()](#getAttrs), or [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29)'},
    {type:'object',name:'sections',description:'Object that contains arrays of all the IDs in sections on the sheet indexed by repeating name.'}
  ]
};
const _removeRepeatingRow = function(row,attributes,sections){
  debug(`removing ${row}`);
  Object.keys(attributes.attributes).forEach((key)=>{
    if(key.startsWith(row)){
      delete attributes[key];
    }
  });
  let [,section,rowID] = row.match(/(repeating_[^_]+)_(.+)/,'');
  sections[section] = sections[section].filter((id)=>id!==rowID);
  removeRepeatingRow(row);
};
kFuncs.removeRepeatingRow = _removeRepeatingRow;

/**
 * Alias for [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29) that converts the default object of attribute values into an {@link attributesProxy} and passes that back to the callback function.
 * @name getAttrs
 * @param {Object} args
 * @param {string[]} [args.props=baseGet] - Array of attribute names to get the value of. Defaults to {@link baseGet} if not passed.
 * @param {function(attributesProxy)} args.callback - The function to call after the attribute values have been gotten. An {@link attributesProxy} is passed to the callback.
 */
docs.js['k.getAttrs'] = {
  type:'function',
  invocation:`k.getAttrs({props,callback})`,
  description:'Alias for [getAttrs](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28_RowID_.29) that converts the default object of attribute values into a K-scaffold attributes object and passes that back to the callback function.',
  arguments:[
    {type:'array',name:'props',description:'Array of attribute names to get the values of as per the [getAttrs() sheetworker](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29). If not passed, gets all the attributes contained in the cascades object.'},
    {type:'function',name:'callback',description:'The function to call after the attribute values have been gotten. Works the same as the callback for the [getAttrs() sheetworker](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29).'}
  ]
};
const _getAttrs = function({props=baseGet,callback}){
  getAttrs(props,(values)=>{
    const attributes = createAttrProxy(values);
    callback(attributes);
  });
};
kFuncs.getAttrs = _getAttrs;

/**
 * Alias for [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29) and [getSectionIDs](https://wiki.roll20.net/Sheet_Worker_Scripts#getSectionIDs.28section_name.2Ccallback.29) that combines the actions of both sheetworker functions and converts the default object of attribute values into an {@link attributesProxy}. Also gets the details on how to handle all attributes from the master {@link cascades} object and.
 * @param {Object} args
 * @param {string[]} [args.props=baseGet] - Array of attribute names to get the value of. Defaults to {@link baseGet} if not passed.
 * @param {repeatingSectionDetails} sectionDetails - Array of details about a section to get the IDs for and attributes that need to be gotten. 
 * @param {function(attributesProxy,sectionObj,expandedCascade):void} args.callback - The function to call after the attribute values have been gotten. An {@link attributesProxy} is passed to the callback along with a {@link sectionObj} and {@link expandedCascade}.
 */
docs.js['k.getAllAttrs'] = {
  type:'function',
  invocation:`k.getAllAttrs({props,sectionDetails,callback})`,
  description:'Alias for [getAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29) and [getSectionIDs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getSectionIDs.28section_name.2Ccallback.29) that combines the actions of both sheetworker functions and converts the default object of attribute values into a K-scaffold attributes object. ',
  arguments:[
    {type:'array',name:'props',description:'Array of attribute names to get the values of as per the [getAttrs() sheetworker](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29).'},
    {type:'array',name:'sectionDetails',description:'An array of objects that contain the details on how to handle a given repeating section. See [k.getSections](#getSections) for more details.'},
    {type:'function',name:'callback(attributes,sections,casc)',description:'The function to call after the attribute values have been gotten. Three arguments are passed to the callback; `attributes`, `sections`, and `casc`. `sections` is an object that holds arrays of row ids, indexed by repeating section name. `casc` is the expanded version of the cascades object with repeating attributes including their row IDs.'}
  ]
};
const getAllAttrs = function({props=baseGet,sectionDetails=repeatingSectionDetails,callback}){
  getSections(sectionDetails,(repeats,sections)=>{
    getAttrs([...props,...repeats],(values)=>{
      const attributes = createAttrProxy(values);
      orderSections(attributes,sections);
      const casc = expandCascade(cascades,sections,attributes);
      callback(attributes,sections,casc);
    })
  });
};
kFuncs.getAllAttrs = getAllAttrs;

/**
 * Alias for [getSectionIDs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getSectionIDs.28section_name.2Ccallback.29) that allows you to iterate through several functions at once. Also assembles an array of repeating attributes to get.
 * @param {object[]} sectionDetails - Array of details about a section to get the IDs for and attributes that need to be gotten.
 * @param {string} sectionDetails.section - The full name of the repeating section including the `repeating_` prefix.
 * @param {string[]} sectionDetails.fields - Array of field names that need to be gotten from the repeating section
 * @param {function(string[],sectionObj)} callback - The function to call once all IDs have been gotten and the array of repating attributes to get has been assembled. The callback is passed the array of repating attributes to get and a {@link sectionObj}.
 * @returns {void}
 */
docs.js['k.getSections'] = {
  type:'function',
  invocation:`k.getSections(sectionDetails,callback)`,
  description:'Alias for [getSectionIDs()](https://wiki.roll20.net/Sheet_Worker_Scripts#getSectionIDs.28section_name.2Ccallback.29) that allows you to iterate through several sections at once. Also assembles an array of repeating attributes to get.',
  arguments:[
    {type:'array',name:'props',description:'Array of attribute names to get the values of as per the [getAttrs() sheetworker](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29).'},
    {type:'array',name:'sectionDetails',description:'An array of objects that contain the details on how to handle a given repeating section. See [k.repeatingSectionDetails](#krepeatingsectiondetails) for more details.'},
    {type:'function',name:'callback(repeatAttrs,sections)',description:'The function to call after the attribute values have been gotten. Two arguments are passed to the callback; `repeatAttrs` and `sections`. `repeatAttrs` is an array of repeating attributes ready to be used in a [getAttrs](https://wiki.roll20.net/Sheet_Worker_Scripts#getAttrs.28attributeNameArray.2C_callback.29), or [k.getAttrs](#kgetattrs) call. `sections` is an object that holds arrays of row ids, indexed by repeating section name.'}
  ]
};
const getSections = function(sectionDetails,callback){
  let queueClone = _.clone(sectionDetails);
  const worker = (queue,repeatAttrs=[],sections={})=>{
    let detail = queue.shift();
    getSectionIDs(detail.section,(IDs)=>{
      sections[detail.section] = IDs;
      IDs.forEach((id)=>{
        detail.fields.forEach((f)=>{
          repeatAttrs.push(`${detail.section}_${id}_${f}`);
        });
      });
      repeatAttrs.push(`_reporder_${detail.section}`);
      if(queue.length){
        worker(queue,repeatAttrs,sections);
      }else{
        callback(repeatAttrs,sections);
      }
    });
  };
  if(!queueClone[0]){
    callback([],{});
  }else{
    worker(queueClone);
  }
};
kFuncs.getSections = getSections;

// Sets the attributes while always calling with {silent:true}
// Can be awaited to get the values returned from _setAttrs
/**
 * Alias for [setAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#setAttrs.28values.2Coptions.2Ccallback.29) that sets silently by default.
 * @name setAttrs
 * @param {object} obj - The object containting attributes to set
 * @param {boolean} [vocal=false] - Whether to set silently (default value) or not.
 * @param {function()} [callback] - The callback function to invoke after the setting has been completed. No arguments are passed to the callback function.
 * @returns {void}
 */
docs.js['k.setAttrs'] = {
  type:'function',
  invocation:`k.setAttrs(setObj,vocal,callback)`,
  description:'Alias for [setAttrs()](https://wiki.roll20.net/Sheet_Worker_Scripts#setAttrs.28values.2Coptions.2Ccallback.29) that sets silently by default.',
  arguments:[
    {type:'object',name:'setObj',description:'Object with key/value pairs of attributes to set on the sheet. See [the wiki page](https://wiki.roll20.net/Sheet_Worker_Scripts#setAttrs.28values.2Coptions.2Ccallback.29) for more information.'},
    {type:'boolean',name:'vocal',description:'Whether to set silently (default value) or not.'},
    {type:'function',name:'callback()',description:'The callback function to invoke after the setting has been completed. No arguments are passed to the callback function.'}
  ]
};
const set = function(obj,vocal=false,callback){
  setAttrs(obj,{silent:!vocal},callback);
};
kFuncs.setAttrs = set;

/**
 * Alias for generateRowID that adds the new id to the {@link sectionObj}. Also allows for creation of custom IDs that conform to the section ID requirements.
 * @name generateRowID
 * @param {string} section - The section name to create an ID for. The `repeating_` prefix is optional so both `repeating_equipment` and `equipment` are valid.
 * @param {sectionObj} sections
 * @param {string} [customText] - Custom text to start the ID with. This text should not be longer than the standard repeating section ID format.
 * @returns {any}
 */
docs.js['k.generateRowID'] = {
  type:'function',
  invocation:`k.generateRowID(section,sections,customText)`,
  description:'Alias for generateRowID that adds the new id to the sections object. Also allows for creation of custom IDs that conform to the section ID requirements.',
  arguments:[
    {type:'string',name:'setObj',description:'The section name to create an ID for. The `repeating_` prefix is optional so both `repeating_equipment` and `equipment` are valid.'},
    {type:'object',name:'vocal',description:'Object containing the IDs for the repeating sections, indexed by repeating section name.'},
    {type:'string',name:'customText',description:'Custom text to start the ID with. This text should not be longer than the standard repeating section ID format.'}
  ]
};
const _generateRowID = function(section,sections,customText){
  let rowID = customText ?
    generateCustomID(customText) :
    generateRowID();
  section = section.match(/^repeating_[^_]+$/) ?
    section :
    `repeating_${section}`;
  sections[section] = sections[section] || [];
  sections[section].push(rowID);
  return `${section}_${rowID}`;
};
kFuncs.generateRowID = _generateRowID;/*jshint esversion: 11, laxcomma:true, eqeqeq:true*/
/*jshint -W014,-W084,-W030,-W033*/
const listeners = {};
const baseGet = Object.entries(cascades).reduce((memo,[attrName,detailObj])=>{
  if(!/repeating/.test(attrName) && detailObj.type !== 'action'){
    memo.push(detailObj.name);
  }
  if(detailObj.listener){
    listeners[detailObj.listener] = detailObj.listenerFunc;
  }
  return memo;
},[]);
const registerEventHandlers = function(){
  on('sheet:opened',updateSheet);
  debug({funcKeys:Object.keys(funcs),funcs});
  //Roll20 change and click listeners
  Object.entries(listeners).forEach(([event,funcName])=>{
    if(funcs[funcName]){
      on(event,funcs[funcName]);
    }else{
      debug(`!!!Warning!!! no function named ${funcName} found. No listener created for ${event}`,true);
    }
  });
  log(`kScaffold Loaded`);
};
setTimeout(registerEventHandlers,0);//Delay the execution of event registration to ensure all event properties are present.
return kFuncs;}());
  
</script>